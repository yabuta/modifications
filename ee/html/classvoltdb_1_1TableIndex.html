<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>voltdb::TableIndex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacevoltdb.html">voltdb</a>::<a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a>
  </div>
</div>
<div class="contents">
<h1>voltdb::TableIndex Class Reference</h1><!-- doxytag: class="voltdb::TableIndex" -->
<p><code>#include &lt;<a class="el" href="tableindex_8h_source.html">tableindex.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for voltdb::TableIndex:</div>
<div class="dynsection">
<div class="center"><img src="classvoltdb_1_1TableIndex__inherit__graph.png" border="0" usemap="#voltdb_1_1TableIndex_inherit__map" alt="Inheritance graph"/></div>
<map name="voltdb_1_1TableIndex_inherit__map" id="voltdb_1_1TableIndex_inherit__map">
<area shape="rect" id="node3" href="classvoltdb_1_1CompactingHashMultiMapIndex.html" title="voltdb::CompactingHashMultiMapIndex\&lt; KeyType \&gt;" alt="" coords="245,5,616,35"/><area shape="rect" id="node5" href="classvoltdb_1_1CompactingHashUniqueIndex.html" title="voltdb::CompactingHashUniqueIndex\&lt; KeyType \&gt;" alt="" coords="253,59,608,88"/><area shape="rect" id="node7" href="classvoltdb_1_1CompactingTreeMultiMapIndex.html" title="voltdb::CompactingTreeMultiMapIndex\&lt; KeyValuePair, hasRank \&gt;" alt="" coords="200,112,661,141"/><area shape="rect" id="node9" href="classvoltdb_1_1CompactingTreeUniqueIndex.html" title="voltdb::CompactingTreeUniqueIndex\&lt; KeyValuePair, hasRank \&gt;" alt="" coords="208,165,653,195"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for voltdb::TableIndex:</div>
<div class="dynsection">
<div class="center"><img src="classvoltdb_1_1TableIndex__coll__graph.png" border="0" usemap="#voltdb_1_1TableIndex_coll__map" alt="Collaboration graph"/></div>
<map name="voltdb_1_1TableIndex_coll__map" id="voltdb_1_1TableIndex_coll__map">
<area shape="rect" id="node4" href="classvoltdb_1_1IndexStats.html" title="voltdb::IndexStats" alt="" coords="945,173,1092,203"/><area shape="rect" id="node2" href="classvoltdb_1_1TupleSchema.html" title="voltdb::TupleSchema" alt="" coords="5,44,168,73"/><area shape="rect" id="node8" href="classvoltdb_1_1TableTuple.html" title="voltdb::TableTuple" alt="" coords="371,151,512,180"/><area shape="rect" id="node17" href="structvoltdb_1_1TableIndexScheme.html" title="voltdb::TableIndexScheme" alt="" coords="341,44,541,73"/><area shape="rect" id="node6" href="classvoltdb_1_1StatsSource.html" title="voltdb::StatsSource" alt="" coords="680,196,837,225"/><area shape="rect" id="node13" href="classvoltdb_1_1NValue.html" title="voltdb::NValue" alt="" coords="381,279,501,308"/><area shape="rect" id="node21" href="classvoltdb_1_1ThreadLocalPool.html" title="voltdb::ThreadLocalPool" alt="" coords="351,97,532,127"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classvoltdb_1_1TableIndex-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a139cfe1b5572f4da7e163f76e6197dd3">~TableIndex</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a29ae1a4830543a5345f12d20f8f50bfb">addEntry</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *tuple)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a738d93d27381b1e3366d8f7770a48c16">deleteEntry</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *tuple)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a3b21b1e90ee81421151b3218266cd1f0">replaceEntryNoKeyChange</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;destinationTuple, const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;originalTuple)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ab6692a13c8c7dd875c20de4949225904">keyUsesNonInlinedMemory</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a2e360bbb63d40400e315b2ed447adc51">exists</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *values) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#af36b3bc45b567526f4c4b6996ca4107a">moveToKey</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a776a96c5455bd7d92eecaa59cd6b8b7a">moveToKeyOrGreater</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a0925c75da098756bc7e6b7558703389f">moveToGreaterThanKey</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a9942eb253c765d819ac5d8087fb85c0f">moveToLessThanKey</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a9f32748c2188b17eee0324fce14fe045">moveToBeforePriorEntry</a> (<a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#acf223e939cbc82265eca532fc1bfdfd2">moveToEnd</a> (bool begin, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a98c1c7e7ce4d58083a183e5f3e7f6417">nextValue</a> (<a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ae0a4e469eb81f750916de1aab36fec7b">nextValueAtKey</a> (<a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#acd3318decca01319b3f5f5b90ac018f1">advanceToNextKey</a> (<a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ab3ee5082e31c6215f41365bf4dd3ac89">uniqueMatchingTuple</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;searchTuple) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a96cb3f93312a136c734df517bd604956">checkForIndexChange</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *lhs, const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *rhs) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ac45742e9947ab44be3c7893f29c1c7bc">isUniqueIndex</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a335c191309ae9cab2e03b4b15e53519b">isCountableIndex</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a065218cfaae902a9ba4593832c51c861">hasKey</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a8645f98c7c3ce5651ca302bff78cd3a7">getCounterGET</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, bool isUpper, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ae67f6c9da36ed54d1c59927ca9fbf36f">getCounterLET</a> (const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *searchKey, bool isUpper, <a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;cursor) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aebeb7c00bbde1b544ce5f76c0b3f5de3">getSize</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a3dfa7d71793aa9e30169e4ee0e6771a4">getMemoryEstimate</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a95608ac1e36135b0efbd57932b31529e">getColumnIndices</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classvoltdb_1_1AbstractExpression.html">AbstractExpression</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a3817769fcd19eaa66c79c00a2a1ec66d">getIndexedExpressions</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a8453f5b57bf2b7aa962097f0dfeb27d0">getName</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a9a4a8150541d410290f68ebf26e4ed40">rename</a> (std::string name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aae4374fefcdd90864a31039919399c9d">getId</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ae2537bbcf1a902e58b3c1da656b1d6db">getKeySchema</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aca34a3e09d350c9df248192983e5a69e">debug</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ac3cbb50fdd951484b32e98fcb3c73dd4">getTypeName</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#af34642c0885d927fdc6d853481a57f2f">ensureCapacity</a> (uint32_t capacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a784910cb07236fdd1828f7df740624fe">printReport</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a7e785231d5ea1c5e8c8c50efc637a2a9">equals</a> (const <a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> *other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoltdb_1_1IndexStats.html">voltdb::IndexStats</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a497d8ebd9025503301f7ea917f22aaf8">getIndexStats</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a48d9486ea96bb077bc0c063ad3a2feb8">getTupleSchema</a> () const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classvoltdb_1_1AbstractExpression.html">AbstractExpression</a> * &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a24cec4993f9b16cf0ddc791e3e8d5b33">simplyIndexColumns</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a20de24fc0ee0787baff30a0c64d8f094">TableIndex</a> (const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a> *keySchema, const <a class="el" href="structvoltdb_1_1TableIndexScheme.html">TableIndexScheme</a> &amp;scheme)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvoltdb_1_1TableIndexScheme.html">TableIndexScheme</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aaba0c618cff603c6b65fbe786cf42e7b">m_scheme</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a> *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#ae3041da27f17bcadc4fee92fd281067b">m_keySchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a6103caacd479da984f2076e1780e3312">m_id</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a136f35a7f623f658608fdc6f32d9a0e2">m_inserts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aa9dd842dc1bf11bd6bfd82683ed9beb6">m_deletes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#aebad83878bd8bfe8870d904798a22b85">m_updates</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoltdb_1_1IndexStats.html">IndexStats</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#a2e60d761a708f2fc6a49819484450bf0">m_stats</a></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoltdb_1_1TableIndex.html#afdcffa3a47dfef97ec52eff2e4245e77">TableIndexFactory</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classvoltdb_1_1TableIndex.html">voltdb::TableIndex</a> class represents a secondary index on a table which is currently implemented as a binary tree (std::map) mapping from key value to tuple pointers. This might involve overhead because of memory fragmentation and pointer tracking on runtime, so we might shift to B+Tree later.</p>
<p><a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> receives a whole <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> to be added/deleted/replaced. <a class="el" href="classvoltdb_1_1PersistentTable.html">PersistentTable</a> passes the <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> in <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> or in <a class="el" href="classvoltdb_1_1UndoLog.html">UndoLog</a> to <a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> for changing/reverting entries in the index. <a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> gets a subset of the <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> only for columns in the index, so there are two types of <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> objects used in different meaning. See method comments to check which the method needs to be passed.</p>
<p><a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> may or may not be a Unique Index. If the index is a unique index, <a class="el" href="classvoltdb_1_1PersistentTable.html">PersistentTable</a> checks uniqueness of inserted/replaced values.</p>
<p><a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> is an abstract class without any implementation. Implementation class is specialized to uniqueness, column types and numbers for higher performance.</p>
<p>See IntsUniqueIndex, IntsMultimapIndex, GenericUniqueIndex, GenericMultimapIndex and ArrayUniqueIndex.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvoltdb_1_1TableIndexFactory.html">TableIndexFactory</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a139cfe1b5572f4da7e163f76e6197dd3"></a><!-- doxytag: member="voltdb::TableIndex::~TableIndex" ref="a139cfe1b5572f4da7e163f76e6197dd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TableIndex::~TableIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20de24fc0ee0787baff30a0c64d8f094"></a><!-- doxytag: member="voltdb::TableIndex::TableIndex" ref="a20de24fc0ee0787baff30a0c64d8f094" args="(const TupleSchema *keySchema, const TableIndexScheme &amp;scheme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TableIndex::TableIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a> *&nbsp;</td>
          <td class="paramname"> <em>keySchema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvoltdb_1_1TableIndexScheme.html">TableIndexScheme</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scheme</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a29ae1a4830543a5345f12d20f8f50bfb"></a><!-- doxytag: member="voltdb::TableIndex::addEntry" ref="a29ae1a4830543a5345f12d20f8f50bfb" args="(const TableTuple *tuple)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::addEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>tuple</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>adds passed value as an index entry linked to given tuple </p>

</div>
</div>
<a class="anchor" id="acd3318decca01319b3f5f5b90ac018f1"></a><!-- doxytag: member="voltdb::TableIndex::advanceToNextKey" ref="acd3318decca01319b3f5f5b90ac018f1" args="(IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::advanceToNextKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>sets the tuple to point the entry next to the one found by <a class="el" href="classvoltdb_1_1TableIndex.html#af36b3bc45b567526f4c4b6996ca4107a">moveToKey()</a>. calls this repeatedly to get all entries following to the search key (for range query).</p>
<p>HOWEVER, this can't be used for partial index search. You can use this only when you in advance know that there is at least one entry that perfectly matches with the search key. In other word, this method SHOULD NOT BE USED in future because there isn't such a case for range query except for cheating case (i.e. TPCC slev which assumes there is always "OID-20" entry).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if any entry to return, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a96cb3f93312a136c734df517bd604956"></a><!-- doxytag: member="voltdb::TableIndex::checkForIndexChange" ref="a96cb3f93312a136c734df517bd604956" args="(const TableTuple *lhs, const TableTuple *rhs) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::checkForIndexChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if lhs is different from rhs in this index, which means replaceEntry has to follow. </dd></dl>

</div>
</div>
<a class="anchor" id="aca34a3e09d350c9df248192983e5a69e"></a><!-- doxytag: member="voltdb::TableIndex::debug" ref="aca34a3e09d350c9df248192983e5a69e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableIndex::debug </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a738d93d27381b1e3366d8f7770a48c16"></a><!-- doxytag: member="voltdb::TableIndex::deleteEntry" ref="a738d93d27381b1e3366d8f7770a48c16" args="(const TableTuple *tuple)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::deleteEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>tuple</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removes the index entry linked to given value (and tuple pointer, if it's non-unique index). </p>

</div>
</div>
<a class="anchor" id="af34642c0885d927fdc6d853481a57f2f"></a><!-- doxytag: member="voltdb::TableIndex::ensureCapacity" ref="af34642c0885d927fdc6d853481a57f2f" args="(uint32_t capacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void voltdb::TableIndex::ensureCapacity </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e785231d5ea1c5e8c8c50efc637a2a9"></a><!-- doxytag: member="voltdb::TableIndex::equals" ref="a7e785231d5ea1c5e8c8c50efc637a2a9" args="(const TableIndex *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TableIndex::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e360bbb63d40400e315b2ed447adc51"></a><!-- doxytag: member="voltdb::TableIndex::exists" ref="a2e360bbb63d40400e315b2ed447adc51" args="(const TableTuple *values) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>values</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>just returns whether the value is already stored. no modification occurs. </p>

</div>
</div>
<a class="anchor" id="a95608ac1e36135b0efbd57932b31529e"></a><!-- doxytag: member="voltdb::TableIndex::getColumnIndices" ref="a95608ac1e36135b0efbd57932b31529e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; voltdb::TableIndex::getColumnIndices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8645f98c7c3ce5651ca302bff78cd3a7"></a><!-- doxytag: member="voltdb::TableIndex::getCounterGET" ref="a8645f98c7c3ce5651ca302bff78cd3a7" args="(const TableTuple *searchKey, bool isUpper, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t voltdb::TableIndex::getCounterGET </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isUpper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function only supports countable tree index. It returns the counter value equal or greater than the serarchKey. It will return the rank with the searchKey in ascending order including itself.</p>
<p>: isUpper means nothing to Unique index. For non-unique index, it will return the high or low rank according to this boolean flag as true or false,respectively.</p>
<p>great than rank value as "m_entries.size() + 1" for given searchKey that is larger than all keys. </p>

</div>
</div>
<a class="anchor" id="ae67f6c9da36ed54d1c59927ca9fbf36f"></a><!-- doxytag: member="voltdb::TableIndex::getCounterLET" ref="ae67f6c9da36ed54d1c59927ca9fbf36f" args="(const TableTuple *searchKey, bool isUpper, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t voltdb::TableIndex::getCounterLET </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isUpper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function only supports countable tree index. It returns the counter value equal or less than the serarchKey. It will return the rank with the searchKey in ascending order including itself.</p>
<p>: isUpper means nothing to Unique index. For non-unique index, it will return the high or low rank according to this boolean flag as true or false,respectively.</p>
<p>less than rank value as "m_entries.size()" for given searchKey that is larger than all keys. </p>

</div>
</div>
<a class="anchor" id="aae4374fefcdd90864a31039919399c9d"></a><!-- doxytag: member="voltdb::TableIndex::getId" ref="aae4374fefcdd90864a31039919399c9d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; voltdb::TableIndex::getId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3817769fcd19eaa66c79c00a2a1ec66d"></a><!-- doxytag: member="voltdb::TableIndex::getIndexedExpressions" ref="a3817769fcd19eaa66c79c00a2a1ec66d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classvoltdb_1_1AbstractExpression.html">AbstractExpression</a>*&gt;&amp; voltdb::TableIndex::getIndexedExpressions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a497d8ebd9025503301f7ea917f22aaf8"></a><!-- doxytag: member="voltdb::TableIndex::getIndexStats" ref="a497d8ebd9025503301f7ea917f22aaf8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoltdb_1_1IndexStats.html">IndexStats</a> * TableIndex::getIndexStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2537bbcf1a902e58b3c1da656b1d6db"></a><!-- doxytag: member="voltdb::TableIndex::getKeySchema" ref="ae2537bbcf1a902e58b3c1da656b1d6db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a>* voltdb::TableIndex::getKeySchema </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dfa7d71793aa9e30169e4ee0e6771a4"></a><!-- doxytag: member="voltdb::TableIndex::getMemoryEstimate" ref="a3dfa7d71793aa9e30169e4ee0e6771a4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int64_t voltdb::TableIndex::getMemoryEstimate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8453f5b57bf2b7aa962097f0dfeb27d0"></a><!-- doxytag: member="voltdb::TableIndex::getName" ref="a8453f5b57bf2b7aa962097f0dfeb27d0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; voltdb::TableIndex::getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aebeb7c00bbde1b544ce5f76c0b3f5de3"></a><!-- doxytag: member="voltdb::TableIndex::getSize" ref="aebeb7c00bbde1b544ce5f76c0b3f5de3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t voltdb::TableIndex::getSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48d9486ea96bb077bc0c063ad3a2feb8"></a><!-- doxytag: member="voltdb::TableIndex::getTupleSchema" ref="a48d9486ea96bb077bc0c063ad3a2feb8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a>* voltdb::TableIndex::getTupleSchema </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3cbb50fdd951484b32e98fcb3c73dd4"></a><!-- doxytag: member="voltdb::TableIndex::getTypeName" ref="ac3cbb50fdd951484b32e98fcb3c73dd4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string voltdb::TableIndex::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a065218cfaae902a9ba4593832c51c861"></a><!-- doxytag: member="voltdb::TableIndex::hasKey" ref="a065218cfaae902a9ba4593832c51c861" args="(const TableTuple *searchKey) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::hasKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a335c191309ae9cab2e03b4b15e53519b"></a><!-- doxytag: member="voltdb::TableIndex::isCountableIndex" ref="a335c191309ae9cab2e03b4b15e53519b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool voltdb::TableIndex::isCountableIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as isUniqueIndex... </p>

</div>
</div>
<a class="anchor" id="ac45742e9947ab44be3c7893f29c1c7bc"></a><!-- doxytag: member="voltdb::TableIndex::isUniqueIndex" ref="ac45742e9947ab44be3c7893f29c1c7bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool voltdb::TableIndex::isUniqueIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Currently, UniqueIndex is just a <a class="el" href="classvoltdb_1_1TableIndex.html">TableIndex</a> with additional checks. We might have to make a different class in future for maximizing performance of UniqueIndex. </p>

</div>
</div>
<a class="anchor" id="ab6692a13c8c7dd875c20de4949225904"></a><!-- doxytag: member="voltdb::TableIndex::keyUsesNonInlinedMemory" ref="ab6692a13c8c7dd875c20de4949225904" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::keyUsesNonInlinedMemory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does the key out-of-line strings or binary data? Used for an optimization when key values are the same. </p>

</div>
</div>
<a class="anchor" id="a9f32748c2188b17eee0324fce14fe045"></a><!-- doxytag: member="voltdb::TableIndex::moveToBeforePriorEntry" ref="a9f32748c2188b17eee0324fce14fe045" args="(IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void voltdb::TableIndex::moveToBeforePriorEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf223e939cbc82265eca532fc1bfdfd2"></a><!-- doxytag: member="voltdb::TableIndex::moveToEnd" ref="acf223e939cbc82265eca532fc1bfdfd2" args="(bool begin, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void voltdb::TableIndex::moveToEnd </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method moves to the beginning or the end of the indexes. Use this with <a class="el" href="classvoltdb_1_1TableIndex.html#a98c1c7e7ce4d58083a183e5f3e7f6417">nextValue()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>begin true to move to the beginning, false to the end. </dd></dl>

</div>
</div>
<a class="anchor" id="a0925c75da098756bc7e6b7558703389f"></a><!-- doxytag: member="voltdb::TableIndex::moveToGreaterThanKey" ref="a0925c75da098756bc7e6b7558703389f" args="(const TableTuple *searchKey, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::moveToGreaterThanKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method moves to the first tuple greater than given key. Use this with <a class="el" href="classvoltdb_1_1TableIndex.html#a98c1c7e7ce4d58083a183e5f3e7f6417">nextValue()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>searchKey the value to be searched. this is NOT tuple data, but chosen values for this index. So, searchKey has to contain values in this index's entry order. </dd></dl>

</div>
</div>
<a class="anchor" id="af36b3bc45b567526f4c4b6996ca4107a"></a><!-- doxytag: member="voltdb::TableIndex::moveToKey" ref="af36b3bc45b567526f4c4b6996ca4107a" args="(const TableTuple *searchKey, IndexCursor &amp;cursor) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::moveToKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method moves to the first tuple equal to given key. To iterate through all entries with the key (if non-unique index) or all entries that follow the entry, use <a class="el" href="classvoltdb_1_1TableIndex.html#ae0a4e469eb81f750916de1aab36fec7b">nextValueAtKey()</a> and <a class="el" href="classvoltdb_1_1TableIndex.html#acd3318decca01319b3f5f5b90ac018f1">advanceToNextKey()</a>.</p>
<p>This method can be used <b>only for perfect matching</b> in which the whole search key matches with at least one entry in this index. For example, (a,b,c)=(1,3,2),(1,3,3),(2,1,2),(2,1,3)....</p>
<p>This method works for "WHERE a=2 AND b=1 AND c&gt;=2", but does not work for "WHERE a=2 AND b=1 AND c&gt;=1". For partial index search, use moveToKeyOrGreater.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>searchKey the value to be searched. this is NOT tuple data, but chosen values for this index. So, searchKey has to contain values in this index's entry order.</dd>
<dd>
moveToKeyOrGreater(const TableTuple *) </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the value is found. false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a776a96c5455bd7d92eecaa59cd6b8b7a"></a><!-- doxytag: member="voltdb::TableIndex::moveToKeyOrGreater" ref="a776a96c5455bd7d92eecaa59cd6b8b7a" args="(const TableTuple *searchKey, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void voltdb::TableIndex::moveToKeyOrGreater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method moves to the first tuple equal or greater than given key. Use this with <a class="el" href="classvoltdb_1_1TableIndex.html#a98c1c7e7ce4d58083a183e5f3e7f6417">nextValue()</a>. This method works for partial index search where following value might not match with any entry in this index.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>searchKey the value to be searched. this is NOT tuple data, but chosen values for this index. So, searchKey has to contain values in this index's entry order. </dd></dl>

</div>
</div>
<a class="anchor" id="a9942eb253c765d819ac5d8087fb85c0f"></a><!-- doxytag: member="voltdb::TableIndex::moveToLessThanKey" ref="a9942eb253c765d819ac5d8087fb85c0f" args="(const TableTuple *searchKey, IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void voltdb::TableIndex::moveToLessThanKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> *&nbsp;</td>
          <td class="paramname"> <em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98c1c7e7ce4d58083a183e5f3e7f6417"></a><!-- doxytag: member="voltdb::TableIndex::nextValue" ref="a98c1c7e7ce4d58083a183e5f3e7f6417" args="(IndexCursor &amp;cursor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> voltdb::TableIndex::nextValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>sets the tuple to point the entry found by <a class="el" href="classvoltdb_1_1TableIndex.html#a776a96c5455bd7d92eecaa59cd6b8b7a">moveToKeyOrGreater()</a>. calls this repeatedly to get all entries with or following to the search key.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if any entry to return, false if reached the end of this index. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0a4e469eb81f750916de1aab36fec7b"></a><!-- doxytag: member="voltdb::TableIndex::nextValueAtKey" ref="ae0a4e469eb81f750916de1aab36fec7b" args="(IndexCursor &amp;cursor) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> voltdb::TableIndex::nextValueAtKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvoltdb_1_1IndexCursor.html">IndexCursor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cursor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>sets the tuple to point the entry found by <a class="el" href="classvoltdb_1_1TableIndex.html#af36b3bc45b567526f4c4b6996ca4107a">moveToKey()</a>. calls this repeatedly to get all entries with the search key (for non-unique index).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if any entry to return, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a784910cb07236fdd1828f7df740624fe"></a><!-- doxytag: member="voltdb::TableIndex::printReport" ref="a784910cb07236fdd1828f7df740624fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableIndex::printReport </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a4a8150541d410290f68ebf26e4ed40"></a><!-- doxytag: member="voltdb::TableIndex::rename" ref="a9a4a8150541d410290f68ebf26e4ed40" args="(std::string name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void voltdb::TableIndex::rename </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b21b1e90ee81421151b3218266cd1f0"></a><!-- doxytag: member="voltdb::TableIndex::replaceEntryNoKeyChange" ref="a3b21b1e90ee81421151b3218266cd1f0" args="(const TableTuple &amp;destinationTuple, const TableTuple &amp;originalTuple)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool voltdb::TableIndex::replaceEntryNoKeyChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destinationTuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>originalTuple</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update in place an index entry with a new tuple address </p>

</div>
</div>
<a class="anchor" id="a24cec4993f9b16cf0ddc791e3e8d5b33"></a><!-- doxytag: member="voltdb::TableIndex::simplyIndexColumns" ref="a24cec4993f9b16cf0ddc791e3e8d5b33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt;<a class="el" href="classvoltdb_1_1AbstractExpression.html">AbstractExpression</a>*&gt;&amp; voltdb::TableIndex::simplyIndexColumns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3ee5082e31c6215f41365bf4dd3ac89"></a><!-- doxytag: member="voltdb::TableIndex::uniqueMatchingTuple" ref="ab3ee5082e31c6215f41365bf4dd3ac89" args="(const TableTuple &amp;searchTuple) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> voltdb::TableIndex::uniqueMatchingTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoltdb_1_1TableTuple.html">TableTuple</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>searchTuple</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>retrieves from a primary key index the persistent tuple matching the given temp tuple </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="afdcffa3a47dfef97ec52eff2e4245e77"></a><!-- doxytag: member="voltdb::TableIndex::TableIndexFactory" ref="afdcffa3a47dfef97ec52eff2e4245e77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classvoltdb_1_1TableIndexFactory.html">TableIndexFactory</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa9dd842dc1bf11bd6bfd82683ed9beb6"></a><!-- doxytag: member="voltdb::TableIndex::m_deletes" ref="aa9dd842dc1bf11bd6bfd82683ed9beb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvoltdb_1_1TableIndex.html#aa9dd842dc1bf11bd6bfd82683ed9beb6">voltdb::TableIndex::m_deletes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6103caacd479da984f2076e1780e3312"></a><!-- doxytag: member="voltdb::TableIndex::m_id" ref="a6103caacd479da984f2076e1780e3312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classvoltdb_1_1TableIndex.html#a6103caacd479da984f2076e1780e3312">voltdb::TableIndex::m_id</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a136f35a7f623f658608fdc6f32d9a0e2"></a><!-- doxytag: member="voltdb::TableIndex::m_inserts" ref="a136f35a7f623f658608fdc6f32d9a0e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvoltdb_1_1TableIndex.html#a136f35a7f623f658608fdc6f32d9a0e2">voltdb::TableIndex::m_inserts</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae3041da27f17bcadc4fee92fd281067b"></a><!-- doxytag: member="voltdb::TableIndex::m_keySchema" ref="ae3041da27f17bcadc4fee92fd281067b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoltdb_1_1TupleSchema.html">TupleSchema</a>* const <a class="el" href="classvoltdb_1_1TableIndex.html#ae3041da27f17bcadc4fee92fd281067b">voltdb::TableIndex::m_keySchema</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaba0c618cff603c6b65fbe786cf42e7b"></a><!-- doxytag: member="voltdb::TableIndex::m_scheme" ref="aaba0c618cff603c6b65fbe786cf42e7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvoltdb_1_1TableIndexScheme.html">TableIndexScheme</a> <a class="el" href="classvoltdb_1_1TableIndex.html#aaba0c618cff603c6b65fbe786cf42e7b">voltdb::TableIndex::m_scheme</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e60d761a708f2fc6a49819484450bf0"></a><!-- doxytag: member="voltdb::TableIndex::m_stats" ref="a2e60d761a708f2fc6a49819484450bf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoltdb_1_1IndexStats.html">IndexStats</a> <a class="el" href="classvoltdb_1_1TableIndex.html#a2e60d761a708f2fc6a49819484450bf0">voltdb::TableIndex::m_stats</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aebad83878bd8bfe8870d904798a22b85"></a><!-- doxytag: member="voltdb::TableIndex::m_updates" ref="aebad83878bd8bfe8870d904798a22b85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvoltdb_1_1TableIndex.html#aebad83878bd8bfe8870d904798a22b85">voltdb::TableIndex::m_updates</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>indexes/<a class="el" href="tableindex_8h_source.html">tableindex.h</a></li>
<li>indexes/<a class="el" href="tableindex_8cpp.html">tableindex.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 2 Oct 2014 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
